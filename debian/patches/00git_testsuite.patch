Description: Pull latest test suite updates from trunk.

Index: udisks2/src/tests/integration-test
===================================================================
--- udisks2.orig/src/tests/integration-test	2012-09-06 10:22:25.233672505 +0200
+++ udisks2/src/tests/integration-test	2012-09-06 10:23:57.673676979 +0200
@@ -119,7 +119,7 @@
 
         print('daemon path: ' + daemon_path)
 
-        klass.device = klass.setup_vdev()
+        (klass.device, klass.cd_device) = klass.setup_vdev()
 
         # start polkit and udisks on a private DBus
         klass.dbus = Gio.TestDBus()
@@ -212,36 +212,46 @@
         klass.sync()
 
     @classmethod
-    def devname(klass, partition=None):
-        '''Get name of test device or one of its partitions'''
+    def devname(klass, partition=None, cd=False):
+        '''Get name of test device or one of its partitions
 
+        If cd is True, return the CD device, otherwise the hard disk device.
+        '''
+        if cd:
+            dev = klass.cd_device
+        else:
+            dev = klass.device
         if partition:
-            if klass.device[-1].isdigit():
-                return klass.device + 'p' + str(partition)
+            if dev[-1].isdigit():
+                return dev + 'p' + str(partition)
             else:
-                return klass.device + str(partition)
+                return dev + str(partition)
         else:
-            return klass.device
+            return dev
 
     @classmethod
-    def udisks_block(klass, partition=None):
-        '''Get UDisksBlock object for test device or partition'''
+    def udisks_block(klass, partition=None, cd=False):
+        '''Get UDisksBlock object for test device or partition
 
+        If cd is True, return the CD device, otherwise the hard disk device.
+        '''
         assert klass.client
-        devname = klass.devname(partition)
+        devname = klass.devname(partition, cd)
         dev_t = os.stat(devname).st_rdev
         block = klass.client.get_block_for_dev(dev_t)
         assert block, 'did not find an UDisksBlock object for %s' % devname
         return block
 
     @classmethod
-    def udisks_filesystem(klass, partition=None):
+    def udisks_filesystem(klass, partition=None, cd=False):
         '''Get UDisksFilesystem object for test device or partition
         
         Return None if there is no file system on that device.
+
+        If cd is True, return the CD device, otherwise the hard disk device.
         '''
-        block = klass.udisks_block(partition)
-        return klass.client.get_object(block.get_object_path()).get_property('filesystem')
+        block = klass.udisks_block(partition, cd)
+        return klass.client.get_object(block.get_object_path()).get_filesystem()
 
     @classmethod
     def blkid(klass, partition=None, device=None):
@@ -364,38 +374,70 @@
         
     @classmethod
     def setup_vdev(klass):
-        '''create virtual test device
+        '''create virtual test devices
         
         It is zeroed out initially.
 
-        Return the device path.
+        Return a pair (writable HD device path, readonly CD device path).
         '''
         # ensure that the scsi_debug module is loaded
         if os.path.isdir('/sys/module/scsi_debug'):
             sys.stderr.write('The scsi_debug module is already loaded; please remove before running this test.\n')
             sys.exit(1)
 
+        # work around scsi_debug not implementing CD-ROM SCSI commands, so that
+        # udev's cdrom_id does not recognize tracks
+        scsi_debug_rules = '/run/udev/rules.d/60-persistent-storage-scsi_debug.rules'
+        if os.path.isdir('/run/udev/rules.d') and not os.path.exists(scsi_debug_rules):
+            with open(scsi_debug_rules, 'w') as f:
+                f.write('''KERNEL=="sr*", ENV{DISK_EJECT_REQUEST}!="?*", ATTRS{model}=="scsi_debug*", ENV{ID_CDROM_MEDIA}=="?*", IMPORT{program}="/sbin/blkid -o udev -p -u noraid $tempnode"
+''')
+            # reload udev
+            subprocess.call('sync; pkill --signal HUP udevd || pkill --signal HUP systemd-udevd',
+                            shell=True)
+
+        # craete a fake SCSI hard drive
         assert subprocess.call(['modprobe', 'scsi_debug', 'dev_size_mb=%i' % (
             VDEV_SIZE/1048576)]) == 0, 'Failure to modprobe scsi_debug'
 
-        # wait until all drives are created
-        dirs = []
-        while len(dirs) < 1:
-            dirs = glob('/sys/bus/pseudo/drivers/scsi_debug/adapter*/host*/target*/*:*/block')
+        # wait until drive got created
+        rw_dirs = []
+        while len(rw_dirs) < 1:
+            rw_dirs = glob('/sys/bus/pseudo/drivers/scsi_debug/adapter*/host*/target*/*:*/block')
+            time.sleep(0.1)
+        assert len(rw_dirs) == 1
+
+        # create a fake CD-ROM, too
+        with open('/sys/bus/pseudo/drivers/scsi_debug/ptype', 'w') as f:
+            f.write('5')  # henceforth, created devices will be CD drives
+        with open('/sys/bus/pseudo/drivers/scsi_debug/add_host', 'w') as f:
+            f.write('1')  # generate a new drive
+        subprocess.call(['udevadm', 'settle'])
+        with open('/sys/bus/pseudo/drivers/scsi_debug/ptype', 'w') as f:
+            f.write('0')
+
+        ro_dirs = []
+        while len(ro_dirs) < 2:
+            ro_dirs = glob('/sys/bus/pseudo/drivers/scsi_debug/adapter*/host*/target*/*:*/block')
             time.sleep(0.1)
-        assert len(dirs) == 1
+        ro_dirs.remove(rw_dirs[0])
+        assert len(ro_dirs) == 1
 
         # determine the debug block devices
-        devs = os.listdir(dirs[0])
+        devs = os.listdir(ro_dirs[0])
+        assert len(devs) == 1
+        ro_dev = '/dev/' + devs[0]
+        devs = os.listdir(rw_dirs[0])
         assert len(devs) == 1
-        dev = '/dev/' + devs[0]
-        assert os.path.exists(dev)
+        rw_dev = '/dev/' + devs[0]
+        assert os.path.exists(ro_dev)
+        assert os.path.exists(rw_dev)
 
         # let's be 100% sure that we pick a virtual one
-        assert open('/sys/block/%s/device/model' % devs[0]).read().strip() == 'scsi_debug'
+        assert open('/sys/block/%s/device/model' % os.path.basename(rw_dev)).read().strip() == 'scsi_debug'
 
-        print('Set up test device: ' + dev)
-        return dev
+        print('Set up test device: r/w: %s, r/o: %s' % (rw_dev, ro_dev))
+        return (rw_dev, ro_dev)
 
     @classmethod
     def teardown_vdev(klass, device):
@@ -806,7 +848,7 @@
         # mount
         mount_path = fs.call_mount_sync(no_options, None)
 
-        self.assertTrue(mount_path.startswith('/run/media/'), mount_path)
+        self.assertTrue('/media/' in mount_path)
         if label:
             self.assertTrue(mount_path.endswith(label))
 
@@ -1090,12 +1132,24 @@
             self.assertTrue(mount_path.endswith('treasure'))
 
             # removal should clean up mounts
-            self.remove_device(self.device)
-            self.assertFalse(os.path.exists(mount_path))
-            self.assertEqual(self.client.get_object(path), None)
+            try:
+                self.remove_device(self.device)
+                self.assertFalse(os.path.exists(mount_path))
+                timeout = 50
+                while timeout > 0:
+                    if self.client.get_object(path) is None:
+                        break
+                    timeout -= 1
+                    # we do not have a main loop, and cannot currently use
+                    # g_main_context_get_default() from introspection, so
+                    # instead of refreshing self.client, get a new one
+                    self.client = UDisks.Client.new_sync(None)
+                    time.sleep(0.1)
+                self.assertGreater(timeout, 0, 'timeout waiting for object path %s to disappear' % path)
+            finally:
+                self.readd_devices()
 
             # after putting it back, it should be mountable again
-            self.readd_devices()
             crypt_obj = self.client.get_object(self.udisks_block().get_object_path())
             path = crypt_obj.get_property('encrypted').call_unlock_sync('s3kr1t', 
                     no_options, None)
@@ -1150,6 +1204,26 @@
         self.assertEqual(block.get_property('id-type'), 'ext4')
         self.assertEqual(block.get_property('id-label'), 'polkityes')
 
+    def test_removable_fs(self):
+        '''Create FS on removable drive (allowed)'''
+
+        self.start_polkitd(['org.freedesktop.udisks2.filesystem-mount'])
+
+        # the scsi_debug CD drive content is the same as for the HD drive, but
+        # udev does not know about this; so give it a nudge to re-probe
+        subprocess.call(['udevadm', 'trigger', '--action=change',
+            '--sysname-match=' + os.path.basename(self.cd_device)])
+        self.sync()
+        self.sync()
+
+        fs = self.udisks_filesystem(cd=True)
+        self.assertNotEqual(fs, None)
+        mount_path = fs.call_mount_sync(no_options, None)
+        self.assertTrue('/media/' in mount_path, mount_path)
+
+        self.retry_busy(fs.call_unmount_sync, no_options, None)
+        self.client.settle()
+
 # ----------------------------------------------------------------------------
 
 if __name__ == '__main__':
